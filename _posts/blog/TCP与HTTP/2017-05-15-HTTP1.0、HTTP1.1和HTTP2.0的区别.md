---
layout: post
title: HTTP1.0、HTTP1.1和HTTP2.0的区别
categories: TCP与HTTP
description: HTTP1.0和HTTP1.1的区别、对HTTP1.x优化和HTTP2.0和HTTP1.X相比的新特性
keywords:  HTTP1.0和HTTP1.1的区别、SPDY、HTTP1.x优化、HTTP2.0和HTTP1.X比较
---

## 1.HTTP的历史
&emsp;&emsp;早在HTTP建立之初，主要就是为了将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。也是说对于前端来说，
我们所写的HTML页面将要放在我们的web服务器上，用户端通过浏览器访问url地址来获取网页的显示内容，但是到了WEB2.0以来，
我们的页面变得复杂，不仅仅单纯的是一些简单的文字和图片，同时我们的HTML页面有了CSS，Javascript，来丰富我们的页面展示，
当ajax的出现，我们又多了一种向服务器端获取数据的方法，这些其实都是基于HTTP协议的。同样到了移动互联网时代，
我们页面可以跑在手机端浏览器里面，但是和PC相比，手机端的网络情况更加复杂，这使得我们开始了不得不对HTTP进行深入理解并不断优化过程中。
#### 1.1 为什么要学HTTP？
我们绝大多数的Web应用都是基于HTTP来进行开发的。我们对Web的操作都是通过HTTP协议来进行传输数据的。  
简单来说，**HTTP协议就是客户端和服务器交互的一种通迅的格式**。  
HTTP的诞生主要是为了能够让文档之间相互关联，形成超文本可以互相传阅  
可以说，Http就是Web通信的基础，这是我们必学的。  
#### 1.2 计算机网络为什么分层？
OSI的7层从上到下分别是 7 应用层 6 表示层 5 会话层 4 传输层 3 网络层 2 数据链路层 1 物理层。  
因为如果两台计算机能够相互通信的话，实际实现起来是非常困难操作的...我们分层的目的就是为了将困难的问题简单化，
并且如果我们分层了，我们在使用的时候就可以仅仅关注我们需要关注的层次，而不用理会其他层。  
<br/>
如果需要改动设计的时候，我们只需要把变动的层替换即可，并不用涉及到其他的层次。这与我们程序设计中的低耦合是一个概念。  
而**我们的HTTP协议是在最上层，也就是应用层**。这是最贴近我们的程序员的层次。
#### 1.3 网站通信粗略过程
我们在Web通信的过程中，不仅仅是需要HTTP协议的，还会涉及到其他的协议的。  

- DNS：负责解析域名:DNS把域名解析成主机地址来进行访问。  
- HTTP：产生请求报文数据：当我们对Web页面进行操作的时候，就会产生HTTP报文数据，请求对应的服务端进行响应。  
- TCP协议：分割HTTP数据，保证数据运输  
- IP协议：传输数据包，找到通信目的地地址。 
#### 1.4 提升传输效率

- 使用压缩技术把实体主体压小，在客户端再把数据解析  
- 使用分块传输编码，将实体主体分块传输，当浏览器解析到实体主体就能够显示了  
- 我们如果在下载东西的过程中断了，可以使用范围请求，获取范围数据，请求没有下载的一部分，继续下载  

断点续传实现：  
1) 客户端下载一个1024K的文件，已经下载了其中512K  
2) 网络中断，客户端请求续传，因此需要在HTTP头中申明本次需要续传的片段：  
```       
Range:bytes=512000- 
```
这个头通知服务端从文件的512K位置开始传输文件  
3) 服务端收到断点续传请求，从文件的512K位置开始传输，并且在HTTP头中增加：  
```
Content-Range:bytes 512000-/1024000
```
并且此时服务端返回的HTTP状态码应该是206，而不是200。  
## 2.HTTP的优化
影响一个HTTP网络请求的因素主要有两个：**带宽和延迟**。
#### 2.1 带宽
&emsp;&emsp;如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，
我们不再会担心由带宽而影响网速，那么就只剩下延迟了。
#### 2.2 延迟

- **浏览器阻塞**：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），
超过浏览器最大连接数限制，后续请求就会被阻塞。  
- **DNS 查询**：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。
这个通常可以利用DNS缓存结果来达到减少这个时间的目的。  
- **建立连接**：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，
但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类较大的请求影响较大。

## 3.HTTP1.0和HTTP1.1的一些区别
HTTP1.1是当前使用最为广泛的HTTP协议，HTTP1.0和HTTP1.1最主要的区别就是HTTP1.1默认是持久化连接，在HTTP1.0默认是短连接。
区别体现在：  
1) **缓存处理**，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，
HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。  
2) **带宽优化及网络连接的使用**，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，
并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），
这样就方便了开发者自由的选择以便于充分利用带宽和连接；断点续传，实际上就是利用HTTP消息头使用分块传输编码，将实体主体分块传输。  
3) **错误通知的管理**，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；
410（Gone）表示服务器上的某个资源被永久性的删除。  
4) **Host头处理**，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。
但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。
HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。  
5) **长连接**，HTTP 1.1支持长连接（PersistentConnection）和请求的管线化（Pipelining）处理。所谓长连接：建立一次连接，多次请求
均由这个连接完成，但只要前一次请求得到响应后才能发下次请求；所谓管线化：不需要等待服务端响应了就可以发送请求了，但是回送数据给
客户端的时候，客户端还是需要按照响应的顺序来一一接收。在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每
次请求都要创建连接的缺点。

![](/images/posts/TCP与HTTP/HTTP与HTTPS区别.png)

## 4.HTTP2.0

- 在HTTP1.0中，发送一次请求时，需要等待服务端响应了才可以继续发送请求。  
- 在HTTP1.1中，发送一次请求时，不需要等待服务端响应了就可以发送请求了，但是回送数据给客户端的时候，客户端还是需要按照响应的
顺序来一一接收  
- 所以说，无论是HTTP1.0还是HTTP1.1提出了Pipelining理论，还是会出现阻塞的情况。从专业的名词上说这种情况，叫做线头阻塞
（Head of line blocking）简称：HOLB  

#### 4.1 HTTP2.0和HTTP1.1相比的新特性
HTTP2与HTTP1.1最重要的区别就是解决了线头阻塞的问题！其中最重要的改动是：多路复用 (Multiplexing)  

1) **新的二进制格式**，HTTP2所有性能增强的核心在于此。HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，
要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。  
2) **多路复用**，即连接共享，如上。即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，
每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。  
3) **header压缩**，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，
通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。  
4) **服务端推送**，同SPDY一样，HTTP2.0也具有server push功能  
## 5.附注
#### 5.1 HTTP2.0的多路复用、HTTP1.1中的长连接、管道化和HTTP1.0的短连接有什么区别？

- HTTP/1.0短连接：一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；  
- HTTP/1.1长连接：若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，
后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；  
- HTTP/1.1管线化：多个请求不用等待服务端响应了就可以发送请求了，但是回送数据给客户端的时候，客户端还是需要按照响应的顺序来一一接收  
- HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；  

#### 5.2 服务器推送到底是什么？
服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，
所以静态资源通过服务端推送的方式可以极大地提升速度。具体如下：  

- 普通的客户端请求过程：  

![](/images/posts/TCP与HTTP/普通客户端请求.png)  

- 服务端推送的过程：  

![](/images/posts/TCP与HTTP/服务端推送.png)  
#### 5.3 为什么头部压缩
假定一个页面有100个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1kb的消息头（这同样也并不少见，因为Cookie和引用等东西的存在）, 
则至少需要多消耗100kb来获取这些消息头。HTTP2.0可以维护一个字典，差量更新HTTP头部，大大降低因头部传输产生的流量。  
#### 5.4 HTTP2.0多路复用有多好？
HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，
会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。  
HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。