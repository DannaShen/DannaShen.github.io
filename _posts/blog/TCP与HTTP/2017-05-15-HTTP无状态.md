---
layout: post
title: HTTP无状态
categories: TCP与HTTP
description: HTTP无状态
keywords: HTTP无状态
---

## 1.HTTP无状态协议描述的问题
HTTP所谓的“无状态协议”，其实跟Cookies、Session这些都没有什么大的联系，它描述的主要是通信协议层面的问题。  
#### 1.1 什么叫有状态的协议
&emsp;&emsp;常见的许多七层协议实际上是有状态的，例如SMTP协议，它的第一条消息必须是HELO，用来握手，在HELO发送之前其他任何命令都是不能发送的；
接下来一般要进行AUTH阶段，用来验证用户名和密码；接下来可以发送邮件数据；最后，通过QUIT命令退出。可以看到，在整个传输层上，
通信的双方是必须要时刻记住当前连接的状态的，因为不同的状态下能接受的命令是不同的；另外，之前的命令传输的某些数据也必须要记住，
可能会对后面的命令产生影响。这种就叫做有状态的协议。  
#### 1.2 为什么HTTP是无状态的协议？
&emsp;&emsp;因为它的每个请求都是完全独立的，每个请求包含了处理这个请求所需的完整的数据，
发送请求不涉及到状态变更。即使在HTTP/1.1上，同一个连接允许传输多个HTTP请求的情况下，如果第一个请求出错了，
后面的请求一般也能够继续处理（当然，如果导致协议解析失败、消息分片错误之类的自然是要除外的）可以看出，这种协议的结构是要比
有状态的协议更简单的，一般来说实现起来也更简单，不需要使用状态机，一个循环就行了——不过，HTTP本身很复杂，这是另一个故事了，这里暂时不提。  
#### 1.3无状态协议优缺点
无状态的协议有一些优点，也有一些缺点。  

- 无状态协议的优点  
和许多人想象的不同，会话（Session）支持其实并不是一个缺点，反而是无状态协议的优点，因为对于有状态协议来说，
如果将会话状态与连接绑定在一起，那么如果连接意外断开，整个会话就会丢失，重新连接之后一般需要从头开始（
当然这也可以通过吸收无状态协议的某些特点进行改进）；而HTTP这样的无状态协议，使用元数据（如Cookies头）来维护会话，
使得会话与连接本身独立起来，这样即使连接断开了，会话状态也不会受到严重伤害，保持会话也不需要保持连接本身。
另外，无状态的优点还在于对中间件友好，中间件无需完全理解通信双方的交互过程，只需要能正确分片消息即可，而且中间件可以很方便地
将消息在不同的连接上传输而不影响正确性，这就方便了负载均衡等组件的设计。  
- 4.2 无状态协议的缺点  
无状态协议的主要缺点在于，单个请求需要的所有信息都必须要包含在请求中一次发送到服务端，这导致单个消息的结构需要比较复杂，
必须能够支持大量元数据，因此HTTP消息的解析要比其他许多协议都要复杂得多。同时，这也导致了相同的数据在多个请求上往往需要反复传输，
例如同一个连接上的每个请求都需要传输Host、Authentication、Cookies、Server等往往是完全重复的元数据，一定程度上降低了协议的效率。  

#### 1.4 HTTP是无状态协议，这句话本身到底对不对
实际上，并不全对。HTTP/1.1中有一个Expect: 100-Continue的功能，它是这么工作的：  
1) 在发送大量数据的时候，考虑到服务端有可能直接拒收数据，客户端发出请求头并附带Expect: 100-Continue的HTTP头，不发送请求体，先等待服务器响应  
2) 服务器收到Expect: 100-Continue的请求，如果允许上传，发送100 Continue的HTTP响应（同一个请求可以有任意个1xx的响应，
均不是最后的Response，只起到提示性作用）；如果不允许，例如不允许上传数据，或者数据大小超出限制，直接返回4xx/5xx的错误  
3) 客户端收到100 Continue的响应之后，继续上传数据  
<br>
&emsp;&emsp;可以看出，这实际上很明显是一个有状态协议的套路，它需要先进行一次握手，然后再真正发送数据。不过，HTTP协议也规定，
如果服务端不进行100 Continue的响应，建议客户端在等待较短的时间之后仍然上传数据，以达成与不支持Expect: 100-Continue功能的服务器的兼容，
这样可以算是“能有状态则有状态，否则回到无状态的路上”，这样说HTTP 1.x是无状态的协议也是没错的。  
<br/>
至于HTTP/2，它应该算是一个有状态的协议了（有握手和GOAWAY消息，有类似于TCP的流控），所以以后说“HTTP是无状态的协议”就不太对了，
最好说“HTTP 1.x是无状态的协议”  
#### 1.5 Cookies和有/无状态的关系 
&emsp;&emsp;关于Cookies和有/无状态的关系，如果把有状态、无状态理解成相同的请求是否返回相同的结果，那么要让某个HTTP服务器有状态，
真的需要Cookies吗？不需要对不对？只需要大家都共享一个全局状态就行了，比如说首页上有一个访问计数器“您是第XXXX个访问本页的用户”，
每访问一次这个计数器就加1，谁访问都加1，这从刚才的理解来说也是“有状态”，对不对？**Cookies/Session的作用是创建和维护多组独立的状态，
而不是有状态。这个状态指的是后端服务的状态，而非HTTP协议本身的状态。所以说，HTTP协议是无状态的协议，这个其实跟服务的状态是无关的。
一个服务不管使用何种协议，都可以在服务层面上是有状态的，因为这和通信协议无关，只需要它在响应请求时改变自己的状态即可**，
例如有一个Shutdown命令可以直接关掉整个服务器不再接受响应，那么它无论如何都是有状态的对吧。所以说，服务本身有没有状态、支不支持会话，
其实跟HTTP协议是否有状态是无关的。
<br/>
TCP一直有状态，HTTP一直无状态，但是应用为了有状态，就给HTTP加了cookie和session机制，让使用http的应用也能有状态，但http还是无状态
## 2.长连接和短连接
#### 2.1 什么是长连接
HTTP1.1规定了默认保持长连接(也有翻译为持久连接)，数据传输完成了保持TCP连接不断开（不发RST包、不四次握手），
等待在同域名下继续用这个通道传输数据；相反的就是短连接。  
<br/>
&emsp;&emsp;HTTP首部的Connection: Keep-alive是HTTP1.0浏览器和服务器的实验性扩展，当前的HTTP1.1 已经默认开启。如果HTTP1.1版本的HTTP请求报文
不希望使用长连接，则要在HTTP请求报文首部加上Connection: close。《HTTP权威指南》提到，有部分古老的HTTP1.0 代理不理解Keep-alive，
而导致长连接失效。其实，在实际使用中不需要考虑这么多，很多时候代理是我们自己控制的，如Nginx代理，代理服务器有长连接处理逻辑，
常见的是客户端跟Nginx代理服务器使用HTTP1.1协议&长连接，而Nginx代理服务器跟后端服务器使用HTTP1.0协议&短连接。
#### 2.2 长连接的过期时间
&emsp;&emsp;客户端的长连接不可能无限期的拿着，会有一个超时时间，服务器有时候会告诉客户端超时时间，譬如：
Keep-Alive: timeout=20，表示这个TCP通道可以保持20秒。另外还可能有max=XXX，表示这个长连接最多接收XXX次请求就断开。
对于客户端来说，如果服务器没有告诉客户端超时时间也没关系，服务端可能主动发起四次握手断开TCP连接，客户端能够知道该TCP连接已经无效；
另外TCP还有心跳包来检测当前连接是否还活着，方法很多，避免浪费资源。
#### 2.3 长连接的数据传输完成识别
使用长连接之后，客户端、服务端怎么知道本次传输结束呢？  

- 判断传输数据是否达到了Content-Length指示的大小；  
- 动态生成的文件没有Content-Length，它是分块传输（chunked），这时候就要根据chunked编码来判断，chunked编码的数据在最后
有一个空chunked块，表明本次传输数据结束。

#### 2.4 并发连接数的数量限制
&emsp;&emsp;在web开发中需要关注浏览器并发连接的数量，RFC文档说，客户端与服务器最多就连上两通道，但服务器、个人客户端要不要这么做就随人意了，
有些服务器就限制同时只能有1个TCP连接，导致客户端的多线程下载（客户端跟服务器连上多条TCP通道同时拉取数据）发挥不了威力，
有些服务器则没有限制。浏览器客户端就比较规矩，限制了同域名下能启动若干个并发的TCP连接去下载资源。并发数量的限制也跟长连接有关联，
打开一个网页，很多个资源的下载可能就只被放到了少数的几条TCP连接里，这就是TCP通道复用（长连接）。
如果并发连接数多，意味着网页上所有资源下载完需要更长的时间（用户感觉页面打开卡了）；并发数多了，服务器可能会产生更高的资源消耗峰值。
浏览器只对同域名下的并发连接做了限制，也就意味着，web开发者可以把资源放到不同域名下，同时也把这些资源放到不同的机器上，这样就完美解决了。  
#### 2.5 容易混淆的概念——TCP的keep alive和HTTp的keep alive
TCP的keep alive是检查当前TCP连接是否活着；HTTP的Keep-alive是要让一个TCP连接活久点。它们是不同层次的概念。  
TCP keep alive的表现：  
当一个连接“一段时间”没有数据通讯时，一方会发出一个心跳包（Keep Alive包），如果对方有回包则表明当前连接有效，继续监控。  
大概44秒，客户端发出了心跳包，服务器及时回应，本TCP连接继续保持。到了空闲60秒的时候，服务器主动发起FIN包，断开连接。
## 3.cookie和session的区别
#### 3.1 session
&emsp;&emsp;由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.
典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，
用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。
在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，
用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。  
#### 3.2 cookie
&emsp;&emsp;思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。
实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，
以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，
会使用一种叫做**URL重写**的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。
<br/>
Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，
访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。  
#### 3.3 总结
Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；  
Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。
#### 3.4 思想
不要混淆 session 和 session 实现。
<br/>  
本来 session 是一个抽象概念，开发者为了实现中断和继续等操作，将 客户端 和 服务器 之间一对一的交互，抽象为“会话”，进而衍生出“会话状态”，
也就是 session 的概念。
<br>
而 cookie 是一个实际存在的东西，http 协议中定义在 header 中的字段。可以认为是 session 的一种后端无状态实现。  
而我们今天常说的 “session”，通常借助 cookie 本身和后端存储实现的，一种更高级的会话状态实现。  
所以 cookie 和 session，你可以认为是同一层次的概念，也可以认为是不同层次的概念。具体到实现，session 因为 session id 的存在，
通常要借助 cookie 实现，但这并非必要，只能说是通用性较好的一种实现方案。


















