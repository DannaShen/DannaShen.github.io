---
layout: post
title: 计算机网络问题
categories: TCP与HTTP
description: 涉及大部分有关计算机网络的问题
keywords: 计算机网络
---

## 1.GET 和 POST 的区别
#### 1.1 GET
查询字符串(名称/值对)是在 GET 请求的 URL 中发送的：/test/demo_form.asp?name1=value1&name2=value2  
- GET请求可被缓存  
- GET请求有长度限制  
- GET请求只应当用于取回数据  
- GET请求保留在浏览器历史记录中  
- GET请求可被收藏为书签  
## 1.2 POST
查询字符串(名称/值对)是在 POST 请求的 HTTP 消息主体中发送的：POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&name2=value2  
- POST请求不会被缓存  
- POST请求对数据长度没要求  
- POST 请求不会保留在浏览器历史记录中  
- POST 不能被收藏为书签  
## 2.DNS使用的协议
既使用TCP又使用UDP  
#### 2.1 TCP与UDP传送字节的长度限制
UDP报文的最大长度为512字节，而TCP则允许报文长度超过512字节。当DNS查询超过512字节时，协议的TC标志出现删除标志，这时则使用TCP发送。
通常传统的UDP报文一般不会大于512字节。
#### 2.2 区域传送时使用TCP
主要有一下两点考虑：  
- 辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。
区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。  
- TCP是一种可靠的连接，保证了数据的准确性。  
#### 2.3 域名解析时使用UDP协议：
客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。
虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。
## 3.幂等
一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，
并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“getUsername()和setTrue()”函数就是一个幂等函数.
## 4.一次完整的HTTP请求过程
域名解析 --> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求，浏览器得到html代码 --> 
浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --> 浏览器对页面进行渲染呈现给用户
## 5.TCP如何保证可靠传输？
1) 三次握手  
2) 将数据截断为合理的长度。应用数据被分割成 TCP 认为最适合发送的数据块（按字节编号，合理分片）  
3) 超时重发。当 TCP 发出一个段后，它启动一个定时器，如果不能及时收到一个确认就重发  
4) 对于收到的请求，给出确认响应  
5) 校验出包有错，丢弃报文段，不给出响应  
6) 对失序数据进行重新排序，然后才交给应用层  
7) 对于重复数据 ， 能够丢弃重复数据  
8) 流量控制。TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据。
这将防止较快主机致使较慢主机的缓冲区溢出。  
9) 拥塞控制。当网络拥塞时，减少数据的发送。  
## 6.http
HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。
所谓的超文本就是带标记的文本，刚开始的时候是指HTML。现在HTTP协议传输的东西可不只是HTML了，什么表单啊JSON啊XML啊文件啊都可以传输。  
#### 6.1 特点
- **简单快速：** 客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。
由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。  
- **灵活：** HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。  
- **无连接：** 无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。  
- **无状态：** HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，
这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。  
- **支持B/S及C/S模式**。
#### 6.2 请求消息
- 请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本。  
- 请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息从第二行起为请求头部，HOST将指出请求的目的地；
User-Agent：服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等  
- 空行，请求头部后面的空行是必须的  
- 请求数据也叫主体，可以添加任意的其他数据。
#### 6.3 响应消息
- 状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。  
- 消息报头，用来说明客户端要使用的一些附加信息  
- 空行，消息报头后面的空行是必须的  
- 响应正文，服务器返回给客户端的文本信息。  
#### 6.4 状态码
- 200 OK //客户端请求成功  
- 301 Moved Permanently //永久重定向,使用域名跳转  
- 302 Found // 临时重定向,未登陆的用户访问用户中心重定向到登录页面  
- 304 它表示该资源被浏览器缓存了不需要重新请求服务器。  
- 400 Bad Request //客户端请求有语法错误，不能被服务器所理解  
- 401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用  
- 403 Forbidden //服务器收到请求，但是拒绝提供服务  
- 404 Not Found //请求资源不存在，eg：输入了错误的URL  
- 500 Internal Server Error //服务器发生不可预期的错误  
- 502 Bad Gateway 后端服务挂掉或者压力过大的时候， Nginx接到的请求无法及时传递给后端的服务进行处理，这个时候就会出现502错误。这个也非常常见  
- 503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常
#### 6.5 HTTP方法
- get:客户端向服务端发起请求，获得资源。请求获得URL处所在的资源  
- post:向服务端提交新的请求字段。请求URL的资源后添加新的数据  
- head:请求获取URL资源的响应报告，即获得URL资源的头部  
- patch：请求局部修改URL所在资源的数据项  
- put：请求修改URL所在资源的数据元素  
- delete：请求删除url资源的数据  
## 7.URI和URL的区别
#### 7.1 URI
是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。Web上可用的每种资源如HTML文档、图像、视频片段、
程序等都是一个用URI来定位的  
<br/>
URI一般由三部组成：  
- 访问资源的命名机制  
- 存放资源的主机名  
- 资源自身的名称，由路径表示，着重强调于资源。
#### 7.2 URL
是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。
URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。
采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。
<br/>
URL一般由三部组成：  
- 协议(或称为服务方式)  
- 存有该资源的主机IP地址(有时也包括端口号)  
- 主机资源的具体地址。如目录和文件名等  
## 8.https是如何保证数据传输的安全
https实际就是在TCP层与http层之间加入了SSL/TLS来为上层的安全保驾护航，主要用到对称加密、非对称加密、证书等技术进行客户端与服务器的数据加密传输，
最终达到保证整个通信的安全性。  
<br/>
SSL/TLS协议作用：  
- 认证用户和服务器，确保数据发送到正确的客户机和服务器；  
- 加密数据以防止数据中途被窃取；  
- 维护数据的完整性，确保数据在传输过程中不被改变。  
![](/images/posts/TCP与HTTP/SSL.png)
## 9.浏览器缓存
问题：前端发布修改后的页面，但是浏览器浏览页面并没有变化。  
#### 9.1 一般的解决方案
1：添加时间戳；2：cache-control。  
- 添加时间戳  
在所有静态资源文件后面添加随机时间戳，例如你的页面里面**用到了test.js**，那你修改过test.js在html页面中的引用就要改成像下面这个样子  
``` html
<script type="text/javascript" src="https://resources.test.com/js/test.js?version=56965"></script>
```
每次修改test.js之后修改version后面的时间戳，这样浏览器就会忽略缓存从服务器请求新的文件，但是，真正这么做了之后，还是会发现，\
即使所有修改过的文件在**应用的时候**都添加了时间戳了，但是页面缓存还是没有清除，这又是为什么呢？原因很简单，
你只对你修改过的文件添加了时间戳，但是html页面本身在这个时候已经被修改了，html页面是所有静态资源的载体，如果不对它加上时间戳，
所有的其他应用都会沿用旧的缓存，所以，这个时候要让缓存失效，只需要在你的访问的网址上面再添加一个时间戳，例如：

``` html
http://www.test.com/index.html?version=123456。
``` 
<br/>
但很明显，这种做法其实很不优雅，例如网站的访问地址是不能经常变更的，所以这种方法其实使用收到很大程度的限制  
- cache-control  
网上很多教程都会写在meta标签上添加cache-control，大概像下面这个样子  

``` html
<meta name="Cache-Control" content="no-cache">
``` 
但是，这样做，一点卵用都没有，这样完全没办法避免浏览器的缓存，添加cache-control没错，但是需要在响应头添加，我们都知道，
客户端跟服务端的交互用的都是http协议，由服务端回传给客户端的数据我们称之为响应数据，分为响应头（Response Headers）和响应体（Response Body），
响应头一般用于指导浏览器以什么样的方式呈现数据，例如编码，解码，压缩，请求能否跨域等操作，Cache-Control是其中的一个，用来指导浏览器如何管理缓存。 
 #### 9.2 浏览器的缓存机制
下面我们详细说一下浏览器的缓存机制，然后再说说如何通过响应头来控制浏览器的缓存，我们首先来看一张流程图
![](/images/posts/TCP与HTTP/浏览器的缓存机制.png)
这张图片是浏览器访问一个有缓存的页面的时候的决策流程，大体上的流程是这样子的，当你访问一个以前访问过的页面，
浏览器会先检查本地缓存是否过期，如果未过期，则直接访问本地缓存，不再从服务器端获取，此时的状态码为200（from cache）。
如已经过期，则会发送一个http请求到服务端，检查两个标识中的其中一个，Etag或者Last-Modified，向浏览器询问资源是否过期，
如未过期，则浏览器会返回一个304状态码，这是浏览器就不会重新下载文件，依旧沿用缓存的内容，但如果此时服务器检测到资源已经过期了，
那么就会返回200状态码，并在响应体中返回最新的资源，覆盖缓存，这样浏览器就能拿到最新的资源了。
那么Etag和Last-Modified这两个字段代表什么呢?Etag是服务端对不同的文件通过固定的算法生成的一个唯一的hash，当文件被修改时，
这个唯一的hash就会发生变化，Last-Modified这个从字面上理解就可以了，他存放的是文件最后的修改时间，这两个都能用来判断当前的文件是否发生了变化。
<br/>
那么接下来我们要做的就是如何通过响应头来指导浏览器控制缓存的时间和什么时候发送询问请求询问资源是否过期，这里会涉及到两个响应头  
1) Expires  
Expires用于指导浏览器缓存文件的时间，具体格式大概是这个样子：Expires:<http-date>，在此时候之后，缓存过期服务器会重新发送确认请求。
如果是无效的日期，比如 0, 代表着过去的日期，也表示该资源已经过期。举个例子：Expires: Wed, 21 Oct 2018 07:28:00 GMT ，
表示在这个时间之前，浏览器都不会向服务器发送请求，都会一直沿用本地的缓存，这里有个地方必须注意，就是如果在Cache-Control响应头设置了
 "max-age" 或者 "s-max-age" 指令，那么 Expires 头会被忽略  
 <br/>
2) Cache-Control  
简单来说，Cache-Control知道浏览器何时向浏览器确认当前资源是否已过期，他有以下选项  
Cache-control: must-revalidate  
Cache-control: no-cache  
Cache-control: no-store  
Cache-control: no-transform  
Cache-control: public  
Cache-control: private  
Cache-control: proxy-revalidate  
Cache-Control: max-age=<seconds>  
Cache-control: s-maxage=<seconds>  
- must-revalidate：缓存必须在使用之前验证旧资源的状态，并且不可使用过期资源  
- public：响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存  
- private：响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）  
- no-cache：在释放缓存副本之前，强制高速缓存将请求提交给原始服务器进行验证
- max-age=<seconds>：设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与Expires相反的是，时间是相对于请求的时间  
- s-maxage=<seconds>：覆盖max-age 或者 Expires 头，但是仅适用于共享缓存(比如各个代理)，并且私有缓存中它被忽略  
- no-store：缓存不应存储有关客户端请求或服务器响应的任何内容。  
- no-transform：不得对资源进行转换或转变。Content-Encoding, Content-Range, Content-Type等HTTP头不能由代理修改。
例如，非透明代理可以对图像格式进行转换，以便节省缓存空间或者减少缓慢链路上的流量。 no-transform指令不允许这样做。  
<br/>  
其中，默认的是private，通常配置比较常用的是no-cache，no-store，max-age。no-cache表示浏览器每次都必须发送查询请求，
询问当前资源是否过期，如果未过期，则返回304，否则放回新资源；no-store则不发生询问，直接获取最新的资源，max-age与expires不同，
他的时间是相对于请求的时间，会覆盖expires中的设定。  
<br/>
所以到了这里，读者应该大体上知道要怎么控制缓存了，比较明智的做法是expires跟cache-control进行搭配使用，根据项目本身的更新周期，
例如一周内不会更新，那么expires可以配置为一周后的日期，那么这段时间内，访问网页的时候，都不会发生http请求，都会直接读取浏览器的缓存，
这样响应速度将会大大提高。cache-control可以设置为no-cache，这样在资源过期之后，浏览器每次加载资源的时候会询问服务器当前资源是否过期，
非过期资源将会继续沿用缓存，虽然发生了http请求，但是不用重新下载数据，这样性能依旧可以保持相对较高的水准。  
## 10.什么是分块传输
当浏览器向服务器请求一个资源时，这个资源是一个动态资源，服务器无法提前预知资源的大小，这个时候就可以使用分块传输。  
<br/>
服务器先生成一个chunk，发送这个chunk，再生成一个chunk，再发送一个chunk，直到全部资源传送完成。
分块传送需要在请求头增加一个特殊的键值对transfer-encoding: chunked，那么消息体的内容便是分块传送的。  
chunked传输格式，由一段一段的分块组合而成，每个块由一个长度行和一个分块体组成，最后一个分块长度为0表示结束。
## 11.什么叫Pipeline管线化？
HTTP1.0不支持管线化，同一个连接处理请求的顺序是逐个应答模式，处理一个请求就需要耗费一个TTL，也就是客户端到服务器的往返时间，
处理N个请求就是N个TTL时长。当页面的请求非常多时，页面加载速度就会非常缓慢。  
![](/images/posts/TCP与HTTP/非管线化.jpg)
从HTTP1.1开始要求服务器支持管线化，可以同时将多个请求发送到服务器，然后逐个读取响应。这个管线化和Redis的管线化原理是一样的，
响应的顺序必须和请求的顺序保持一致。
![](/images/posts/TCP与HTTP/管线化.jpg)





    







 












  










  


   



   







