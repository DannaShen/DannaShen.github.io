---
layout: post
title: MySQL读写分离
categories: 分布式
description: 
keywords: 
---
你们有没有做 MySQL 读写分离？如何实现 MySQL 的读写分离？MySQL 主从复制原理的是啥？如何解决 MySQL 主从同步的延时问题？  
<br/>
高并发这个阶段，肯定是需要做读写分离的，啥意思？因为实际上大部分的互联网公司，一些网站，或者是 app，其实都是读多写少。
所以针对这个情况，就是写一个主库，但是主库挂多个从库，然后从多个从库来读，那不就可以支撑更高的读并发压力了吗？  
## 1. 如何实现MySQL读写分离
就是基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。
## 2. 主从复制的作用
1. 做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。  
2. 架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。  
3. 读写分离，使数据库能支撑更大的并发。在报表中尤其重要。由于部分报表sql语句非常的慢，导致锁表，影响前台服务。
如果前台使用master，报表使用slave，那么报表sql将不会造成前台锁，保证了前台速度。
## 3. 主从复制原理
1. 数据库有个bin-log二进制文件，记录了sql语句。  
2. 我们的目标就是把主数据库的bin-log文件的sql语句复制过来。  
3. 让其在从数据库的relay-log重做日志文件中再执行一次这些sql语句即可。  
4. 下面的主从配置就是围绕这个原理配置  
5. 具体需要三个线程来操作：  

- 1.binlog输出线程:每当有从库连接到主库的时候，主库都会创建一个线程然后发送binlog内容到从库。在从库里，当复制开始的时候，
从库就会创建两个线程进行处理：  
&nbsp;&nbsp;&nbsp; 1. 从库I/O线程:当START SLAVE语句在从库开始执行之后，从库创建一个I/O线程，
该线程连接到主库并请求主库发送binlog里面的更新记录到从库上。从库I/O线程读取主库的binlog输出线程发送的更新并
拷贝这些更新到本地文件，其中包括relay log文件。  
<br/>
&nbsp;&nbsp;&nbsp; 2. 从库的SQL线程:从库创建一个SQL线程，这个线程读取从库I/O线程写到relay log的更新事件并执行。
<br/>
<br/>
可以知道，对于每一个主从复制的连接，都有三个线程。拥有多个从库的主库为每一个连接到主库的从库创建一个binlog输出线程，
每一个从库都有它自己的I/O线程和SQL线程。
主从复制如图：  
![](/images/posts/分布式/读写分离-主从复制.png)  
原理图,帮助理解!   
![](/images/posts/分布式/读写分离-主从复制之理解.png)  
步骤一：主库db的更新事件(update、insert、delete)被写到binlog  
步骤二：从库发起连接，连接到主库  
步骤三：此时主库创建一个binlog dump thread线程，把binlog的内容发送到从库  
步骤四：从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log.  
步骤五：从库还会创建一个SQL线程，从relay log里面读取内容，从Exec_Master_Log_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db.

这里有一个非常重要的一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。
所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行 SQL 的特点，在高并发场景下，从库的数据一定会比主库慢一些，
是有延时的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。  
<br/>
而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，
有些数据可能就丢失了。  
<br/>
所以 MySQL 实际上针对上面两个问题有两个机制，一个是半同步复制，用来解决主库数据丢失问题；一个是并行复制，用来解决主从同步延时问题。  
<br/>
这个所谓半同步复制，也叫 semi-sync 复制，指的就是主库写入 binlog 日志之后，就会将强制此时立即将数据同步到从库，
从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到至少一个从库的 ack 之后才会认为写操作完成了。  
<br/>
所谓并行复制，只是基于schema的，也就是基于库的，比较适用于一个库中存在多个schema的场景。普通的主从复制架构中，
slave服务器上有两个线程：IO线程和SQL线程，在并行复制中，sql线程变为coordinator线程，判断是否可以并发执行：  

- 如可以并行执行，选择worker线程执行二进制日志  
- 如不可并行执行，是DDL或是跨schema的操作，则等待所有的worker线程执行完成之后再执行当前日志  

coordinator线程不仅仅可以将日志发送给worker线程，也可以回放日志，但是并行的操作都会交给worker线程来完成。  
![](/images/posts/分布式/读写分离-并行复制.png)  

即并行复制指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后并行重放不同库的日志或者执行日志，这是库级别的并行。  
<br/>
那么如何并行化? 是并行io线程，还是并行sql线程？其实两方面都可以并行，但是并行sql线程的收益更大，因为sql线程做的事情更多
（解析，执行）。并行IO线程，可以将从master拉取和写入relay log分为两个线程；并行sql线程则可以根据需要做到
库级并行，表级并行，事务级并行。库级并行在MySQL官方版本5.6已经实现了。并行复制框架实际包含了一个协调线程和若干个工作线程。
协调线程负责分发和解决冲突，工作线程只负责执行。  
<br/>
DB1,DB2和DB3的事务就可以并发执行，提高了复制的性能。有时候库级并发可能不够，需要做表级并发，或更细粒的事务级并发。  
<br/>
**并行复制如何处理冲突？**  
   并发的世界是美好的，但不能乱并发，否则数据就乱了。master上面通过锁机制来保证并发的事务有序进行，那么并行复制呢？
   slave必需保证回放的顺序与master上事务执行顺序一致，因此只要做到顺序读取binlog，将不冲突的事务并发执行即可。
   对于库级并发而言，协调线程要保证执行同一个库的事务放在一个工作线程串行执行；对于表级并发而言，
   协调线程要保证同一个表的事务串行执行；对于事务级而言，则是保证操作同一行的事务串行执行。  
<br/>
**是否粒度越细，性能越好？**  
这个并不是一定的。相对与串行复制而言，并行复制多了一个协调线程。协调线程一个重要作用是解决冲突，粒度越细的并发，
可能会有更多的冲突，最终可能也是串行执行的，但消耗了大量的冲突检测代价。
## 4. 主从同步的事件
在master机器上，主从同步事件会被写到特殊的log文件中(binary-log);  
<br/>
主从同步事件有3种形式:statement、row、mixed。  
- statement：会将对数据库操作的sql语句写入到binlog中。  
- row：会将每一条数据的变化写入到binlog中。  
- mixed：statement与row的混合。Mysql决定什么时候写statement格式的，什么时候写row格式的binlog。  

## 5. 主从同步延时问题（精华）
以前线上确实处理过因为主从同步延时问题而导致的线上的 bug，属于小型的生产事故。  
<br/>
是这个么场景。有个同学是这样写代码逻辑的。先插入一条数据，再把它查出来，然后更新这条数据。在生产环境高峰期，
写并发达到了 2000/s，这个时候，主从复制延时大概是在小几十毫秒。线上会发现，每天总有那么一些数据，我们期望更新一些重要的数据状态，
但在高峰期时候却没更新。用户跟客服反馈，而客服就会反馈给我们。  
<br/>
我们通过 MySQL 命令：  

    show status
    
查看 Seconds_Behind_Master，可以看到从库复制主库的数据落后了几 ms。  
<br/>
一般来说，如果主从延迟较为严重，有以下解决方案：  

- 分库，将一个主库拆分为多个主库，每个主库的写并发就减少了几倍，此时主从延迟可以忽略不计。  
- 打开 MySQL 支持的并行复制，多个库并行复制。如果说某个库的写入并发就是特别高，单库写并发达到了 2000/s，并行复制还是没意义。  
- 重写代码，写代码的同学，要慎重，插入数据时立马查询可能查不到。  
- 如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询设置直连主库。
不推荐这种方法，你要是这么搞，读写分离的意义就丧失了。  