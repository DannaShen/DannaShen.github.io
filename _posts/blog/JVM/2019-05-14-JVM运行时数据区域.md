---
layout: post
title: JVM运行时数据区域结构(Java内存结构)
categories: JVM
description: 两个类间的关系：继承(实现)、依赖、关联、聚合和组合
keywords: 类与类间关系、继承与聚合关系、继承、聚合、关联、组合
---
## 1.相关概念
#### 1.1 方法区
 (1)只是JVM规范中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，具体放在哪里，不同的实现可以放在不同的地方。  
永久代是HotSpot虚拟机特有的概念，是对方法区的实现，别的JVM没有永久代的概念。(虽然去除了永久代，但是方法区作为概念上的区域仍然存在)
 (2)在JDK8中，JDK8的HotSpot VM已经是以前的HotSpot VM与JRockit VM的合并版，也就是传说中的“HotRockit”，只是产品里名字还是叫HotSpot VM。
 所以对于说JDK8去除永久代换成元空间的说法，就是默指的合并后的HotSpot虚拟机。 
#### 1.2 为什么要将永久代去除呢？ 
(1)字符串存在永久代中，容易出现性能问题和内存溢出。  
(2)类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。  
(3)永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。  
(4)为了整合JRockit，因为JRockit没有永代区这样类似的空间。  
#### 1.3 元空间又是什么呢？以前存储在永久代里面的数据现在存在了哪里？ 
元空间是一块与堆不相连的本地内存，元空间与永久代之间最大的区别在于元数据空间并不在虚拟机中，而是使用本地内存。
原本存在永久代的数据，一部分移到了java堆里面，一部分移到了本地内存里面(即元空间)。  
永久代中原来存储的字符串常量（池）、符号引用（这两个在jdk7普遍就已经将其放在堆上了）和类的静态变量现在存储在java堆中，
其余的数据作为元数据存储在元空间中。
#### 1.4 什么是元数据呢？ 
元数据是数据的数据或者叫做用来描述数据的数据或者叫做信息的信息。(比如原本方法区存储的类信息、即时编译器编译后的代码等)，
也可以把元数据简单的理解成：最小的数据单位。元数据可以为数据说明其元素或属性（名称、大小、数据类型等），或其结构（长度、字段、数据列），
或其相关数据（位于何处、如何联系、拥有者）。 

## 2.简介
Java虚拟机在执行java程序的过程中会把它所管理的内存划分为若干的不同的数据区域。这些区域各有用途和各自的创建和销毁的时间。  
Java虚拟机运行时数据区域也即Java内存结构,不同于Java内存模型。
下面介绍一下jvm在运行时的数据区域。   
## 2.1 运行时数据区的总体结构与相关信息
jdk7及其以前的组件图：
![](/images/posts/JVM/JVM运行时数据区域结构图(Java内存结构)—JDK7.jpg)
jdk8的组件图：
![](/images/posts/JVM/JVM运行时数据区域结构图(Java内存结构)—JDK8.png)
## 2.2 线程共享和私有区域
线程共享区域：方法区、堆；  
线程私有区域：虚拟机栈（VM Stack）、本地方法栈（Native Stack）、程序计数器
## 3.程序计数器
(1)占有较小的内存空间  
(2)可以看作是当前所执行字节码的行号指示器  
(3)当线程执行java方法时，记录的是正在执行的vm字节码指令的地址。若执行的为Native方法，计数器值为空即undefined。  
(4)唯一一个在jvm中没有规定OutOfMemoryError异常的区域  
## 4.虚拟机栈
(1)线程私有，生命周期与线程相同。
(2)描述的是Java方法执行的内存模型：每一个方法执行的同时都会创建一个栈帧，由于存储局部变量表、操作数栈、动态链接、方法出口等信息。
每一个方法的执行就对应着栈帧在虚拟机栈中的入栈，出栈过程。  
(3)java内存中的常分为堆内存和栈内存，其中的栈内存就可以认为这个VM Stack，或者说是VM Stack中的局部变量表。
(4)**局部变量表**：存放编译期可知的各种**基本数据类型、对象引用类型和returnAddress类型(指向一条字节码指令的地址：函数返回地址)**。
long、double占用两个局部变量控件Slot，其余的占一个Slot。局部变量表所需的内存空间在编译期确定，当进入一个方法时，方法在栈帧中
所需要分配的局部变量控件是完全确定的，不可动态改变大小。
## 5.本地方法栈
(1)为VM提供Native方法服务
(2)本地方法： 
- 当某个线程调用一个本地方法时，便不再受虚拟机的限制。本地方法可以通过本地方法接口来访问虚拟机的运行时数据区。  
- 本地方法本质上是依赖于实现的，虚拟机实现的设计者们可以自由地决定使用怎样的机制来让Java程序调用本地方法。  
- 任何本地方法接口都会使用某种本地方法栈。当线程调用Java方法时，虚拟机会创建一个新的栈帧并压入Java栈。然而当它调用的是本地方法时，
虚拟机会保持Java栈不变，不再在线程的Java栈中压入新的帧，虚拟机只是简单地动态连接并直接调用指定的本地方法。
- 本地方法接口需要回调Java虚拟机中的Java方法时，该线程会保存本地方法栈的状态并进入到另一个Java栈。
(3)HotSpot虚拟机中把本地方法栈和虚拟机栈合二为一。
## 6.java堆
(1)JVM中所管理内存中的最大的一块。在虚拟机启动时被创建。
(2)唯一的目的是存放对象实例，几乎所有的对象实例和数组都是在这里分配内存。(JVM规范中说的是所有的，但是随着JIT便编译器的发展和
逃逸技术分析的成熟，一些实例可以不在这个区域分配内存）
(3)堆是垃圾收集管理的主要区域，所以也会被称为”GC堆“
(4)**浅堆和深堆** 
- 浅堆和深堆是两个非常重要的概念，它们分别表示一个对象结构所占用的内存大小和一个对象被GC回收后，可以真实释放的内存大小。  
- 浅堆是指一个对象所消耗的内存。在32位系统中，一个对象引用会占据4个字节，一个int类型会占据4个字节，long型变量会占据8个字节，
每个对象需要占用8个字节。  
- 深堆的概念略微复杂。要理解深堆，首先需要了解保留集（Retained Set）。对象A的保留集指当对象A被垃圾回收后，**可以**被释放的
所有对象集合（包括对象A本身），即对象A的保留集可以被认为是**只能**通过对象A被直接或间接访问到的所有对象的集合。通俗地说，
就是指**仅被对象A所持有**的对象的集合。深堆是指对象的保留集中所有的对象的浅堆大小之和。  
例如:对象A引用了C和D，对象B引用了C和E。那么对象A的浅堆大小只是A本身，不含C和D，而A的实际大小为A、C、D三者之和。
而A的深堆大小为A与D之和，由于对象C还可以通过对象B访问到，因此不在对象A的深堆范围内。
## 7.方法区
(1)前面已经介绍方法区在JDk8之后的的变动  
(2)JDK7及之前版本的方法区（Method Area）和Java堆一样，是各个线程共享的内存区域，用于存储已经被虚拟机加载的类信息、常量、静态常量、
即时编译器编译后的代码等数据。  
(3)虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但它有另外一个名字叫Non-Heap（非堆）。  
<br>
方法区也可被垃圾收集，例如：在HotSpot中将GC分代收集扩展至方法区。避免了还要再为方法区编写GC算法。
## 8.总结
在java中虚拟机自动内存管理机制下，创建对象不需要像一样自己进行内存的分配，不容易发生内存泄漏等问题，但是一旦发生这些问题
便不容易去找到发生问题的根源，了解JVM的内存模型使你可以更容易的查找原因。