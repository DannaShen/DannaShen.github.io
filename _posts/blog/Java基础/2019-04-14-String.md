---
layout: post
title: String
categories: Java基础
description: String源码解析、创建几个对象及intern等面试问题、StringBuffer和StringBuilder区别等
keywords: String、几个对象、StringBuffer、StringBuilder、intern
---

## String源码解析

  String类被final所修饰，也就是说String对象是不可变量，并发程序最喜欢不可变量了。String类实现了Serializable, Comparable, CharSequence接口。

#### String属性
``` java

    //用一个不可变的char数组来存储字符串
    private final char value[];

    /** Cache the hash code for the string */
    //一个int型的变量用来存储就算后的hash值
    private int hash; // Default to 0
```

#### String构造函数
``` java

    //不含参数的构造函数，一般没什么用，因为value是不可变量
    public String() {
        this.value = "".value;
    }
    
    
    //参数为String类型
    public String(String original) {
        this.value = original.value;
        this.hash = original.hash;
    }
    
    
    //参数为char数组，使用java.utils包中的Arrays类复制
    public String(char value[]) {
        this.value = Arrays.copyOf(value, value.length);
    }
    
    
    //从bytes数组中的offset位置开始，将长度为length的字节，以charsetName格式编码，拷贝到value
    public String(byte bytes[], int offset, int length, String charsetName)
            throws UnsupportedEncodingException {
        if (charsetName == null)
            throw new NullPointerException("charsetName");
        checkBounds(bytes, offset, length);
        this.value = StringCoding.decode(charsetName, bytes, offset, length);
    }
    
```
    
#### String常用方法

##### equals方法

###### 判断原则
1. 内存地址相同，则为真
2. 如果对象类型不是String类型，则为假。否则继续判断。
3. 如果对象长度不相等，则为假。否则继续判断。
4. 从后往前，判断String类中char数组value的单个字符是否相等，有不相等则为假。如果一直相等直到第一个数，则返回真。   
``` java 
    public boolean equals(Object anObject) {
        //如果引用的是同一个对象，返回真
        if (this == anObject) {
            return true;
        }
        //如果不是String类型的数据，返回假
        if (anObject instanceof String) {
            String anotherString = (String)anObject;
            int n = value.length;
            //如果char数组长度不相等，返回假
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                //从后往前单个字符判断，如果有不相等，返回假
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        return false;
    }
 ```   
    

    
##### compareTo方法

###### 判断原则
1. 取两个字符串长度最小值，先从0处开始判断字符大小，如果字符不相等，返回当前对象不相等处字符-被比较对象(所传对象)不想等字符的值。
2. 如果两个对象能比较字符的地方比较完了还相等，就直接返回自身长度减被比较对象长度
3. 如果两个字符串长度相等，则返回的是0，巧妙地判断了三种情况。   
``` java    
    
    public int compareTo(String anotherString) {
        //自身对象字符串长度len1
        int len1 = value.length;
        //被比较对象字符串长度len2
        int len2 = anotherString.value.length;
        //取两个字符串长度的最小值lim
        int lim = Math.min(len1, len2);
        char v1[] = value;
        char v2[] = anotherString.value;
        int k = 0;
        //从value的第一个字符开始到最小长度lim处为止，如果字符不相等，返回自身（当前对象不相等处字符-被比较对象不相等字符）
        while (k < lim) {
            char c1 = v1[k];
            char c2 = v2[k];
            if (c1 != c2) {
                return c1 - c2;
            }
            k++;
        }
        //如果前面都相等，则返回（自身长度-被比较对象长度）
        return len1 - len2;
    }
 ```
    

##### hashCode方法

###### 注意
String类的hash采用多项式计算得来，我们完全可以通过不相同的字符串得出同样的hash，所以两个String对象的hashCode相同，并不代表两个String是一样的。  
``` java

    public int hashCode() {
        int h = hash;
        //如果hash没有被计算过，并且字符串不为空，则进行hashCode计算
        if (h == 0 && value.length > 0) {
            char val[] = value;
            //计算过程：s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]
            for (int i = 0; i < value.length; i++) {
                h = 31 * h + val[i];
            }
            hash = h;//hash赋值
        }
        return h;
    }
 ```   
##### startsWith方法

###### 定义
检测字符串是否以指定的前缀开始，prefix：前缀 toffset：字符串中开始查找的位置 
``` java

    public boolean startsWith(String prefix, int toffset) {
            char ta[] = value;
            int to = toffset;
            char pa[] = prefix.value;
            int po = 0;
            int pc = prefix.value.length;
            // Note: toffset might be near -1>>>1.
            //如果起始地址小于0或者（起始地址+所比较对象长度）大于自身对象长度，返回假
            if ((toffset < 0) || (toffset > value.length - pc)) {
                return false;
            }
            //从所比较对象的末尾开始比较
            while (--pc >= 0) {
                if (ta[to++] != pa[po++]) {
                    return false;
                }
            }
            return true;
    }
```
    
##### concat方法
``` java

    public String concat(String str) {
        int otherLen = str.length();
        if (otherLen == 0) {
            return this;
        }
        int len = value.length;
        char buf[] = Arrays.copyOf(value, len + otherLen);
        str.getChars(buf, len);//将str字符串拷贝到buf
        return new String(buf, true);
    }
```    
##### replace方法
###### 备注
这个方法也有讨巧的地方，例如最开始先找出旧值出现的位置，这样节省了一部分对比的时间
``` java

    public String replace(char oldChar, char newChar) {
        //新旧值比较
        if (oldChar != newChar) {
            int len = value.length;
            int i = -1;
            char[] val = value; /* avoid getfield opcode */
            //找到旧值最开始的地方
            while (++i < len) {
                if (val[i] == oldChar) {
                    break;
                }
            }
            //从那个位置开始直到末尾，用新值替换出现的旧值
            if (i < len) {
                char buf[] = new char[len];
                for (int j = 0; j < i; j++) {
                    buf[j] = val[j];
                }
                while (i < len) {
                    char c = val[i];
                    buf[i] = (c == oldChar) ? newChar : c;
                    i++;
                }
                return new String(buf, true);
            }
        }
        return this;
    }
```
##### trim方法
``` java

    public String trim() {
        int len = value.length;
        int st = 0;
        char[] val = value;    /* avoid getfield opcode */

        while ((st < len) && (val[st] <= ' ')) {
            st++;
        }
        while ((st < len) && (val[len - 1] <= ' ')) {
            len--;
        }
        return ((st > 0) || (len < value.length)) ? substring(st, len) : this;
    }
```
#### 总结

String对象是不可变类型，返回类型为String的String方法每次返回的都是新的String对象，除了某些方法的某些特定条件返回自身。

String对象的三种比较方式：

. ==内存比较：直接对比两个引用所指向的内存值，精确简洁直接明了。

. equals字符串值比较：比较两个引用所指对象字面值是否相等。

. hashCode字符串数值化比较：将字符串数值化。两个引用的hashCode相同，不保证内存一定相同，不保证字面值一定相同。

	




















