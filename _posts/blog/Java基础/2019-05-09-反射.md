---
layout: post
title: 反射使用详解及源码解析
categories: Java基础
description: 反射使用的详解及源码解析
keywords: 反射使用、反射源码
---

## 1.Class类

#### 1.1 什么是Class类
**Class是一个类，封装了当前对象所对应的类的信息**
比如说有一个Person类，一个Order类，一个Book类，这些都是不同的类。现在需要一个类，用来描述类，这就是Class。
正如一个类中有属性，方法，构造器等，因此Class类也有类名，属性，方法，构造器等。Class是用来描述类的类。
<br/>
1) Class类是一个对象照镜子的结果，对象可以看到自己有哪些属性，方法，构造器，实现了哪些接口等等。  
可是，对象为什么需要照镜子呢？  
- 有可能这个对象是别人传过来的
- 有可能没有对象，只有一个全类名 
通过反射，可以得到这个类里面的信息
<br/>
2) 对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个类的有关信息。  
3) Class 对象只能由系统建立对象，一个类（而不是一个对象）在 JVM 中只会有一个Class实例。
 
#### 1.2 什么是反射
反射之中包含了一个「反」字，所以想要解释反射就必须先从「正」开始解释。  
一般情况下，我们使用某个类时必定知道它是什么类，于是我们直接对这个类进行实例化，之后使用这个类对象进行操作。  
``` java
Apple apple = new Apple(); //直接初始化，「正射」
apple.setPrice(4);
```
上面这样子进行类对象的初始化，我们可以理解为「正」。  
反射则是一开始并不知道我要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。  
``` java
Class clz = Class.forName("com.chenshuyi.reflect.Apple");
Method method = clz.getMethod("setPrice", int.class);
Constructor constructor = clz.getConstructor();
Object object = constructor.newInstance();
method.invoke(object, 4);
```
上面两段代码的执行结果，其实是完全一样的。但是其思路完全不一样，第一段代码在未运行时就已经确定了要运行的类（Apple），
而第二段代码则是在运行时通过字符串值才得知要运行的类（com.chenshuyi.reflect.Apple）。  
所以说什么是反射？  
**反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。**
## 2.反射类的使用
Java反射机制主要提供了以下功能：  

- 在运行时构造任意一个类的对象
- 在运行时获取任意一个类所具有的成员变量和方法
- 在运行时调用任意一个对象的方法（属性）
- 生成动态代理
#### 2.1 获取Class对象的三种方式
1) 通过类名获取 类名.class
2) 通过全类名获取 Class.forName(全类名)
3) 通过对象获取 对象名.getClass()
#### 2.2 Method
``` java
Class clazz = Class.forName("com.atguigu.java.fanshe.Person");
```
1) 获取所有方法，包括从父类继承来的，但不能获取私有的方法：  
``` java
 Method[] methods = clazz.getMethods();
 for(Method method:methods){
             System.out.print(" "+method.getName());
 }  
```
2) 获取私有方法，但只获取当前类的  
``` java
 Method[] methods = clazz.getDeclaredMethods();
 for(Method method:methods){
             System.out.print(" "+method.getName());
 }  
```
3) 获取指定的方法  
``` java
 Method method = clazz.getDeclaredMethod("setName", String.class);  
``` 
4) 执行方法  
``` java
Object obje = clazz.newInstance();  
method.invoke(obje,2);  
```
5) 如果一个方法是私有方法,必须在调用invoke之前加上一句method.setAccessible（true）;
#### 2.3 Field
1) 获取所有字段，包括公有的和私有的，但不能获取父类字段  
``` java
 Field[] fields = clazz.getDeclaredFields();
 for(Field field: fields){
             System.out.print(" "+ field.getName());
 } 
```
2) 获取指定字段   
``` java
 Field field = clazz.getDeclaredField("name");
 System.out.println(field.getName()); 
```
3) 使用字段：获取指定对象的指定字段的值  
``` java
 Object val = field.get(person);
 System.out.println(val);
``` 
4) 使用字段：设置指定对象的指定字段的值  
``` java
field.set(person, "DEF");
System.out.println(person.getName());
```
5) 如果字段是私有的，不管是读值还是写值，都必须先调用setAccessible（true）方法
``` java
field = clazz.getDeclaredField("age");
field.setAccessible(true);
System.out.println(field.get(person));
```
#### 2.4 Constructor
1) 获取全部Constructor对象  
``` java
  Constructor<Person> [] constructors = 
                 (Constructor<Person>[]) Class.forName(className).getConstructors(); 
```
2) 获取指定参数的Constructor对象   
``` java
 Constructor<Person> constructor = clazz.getConstructor(String.class, int.class);
```
3) 调用构造器的 newInstance() 方法创建对象 
``` java
  Object obj = constructor.newInstance("zhagn", 1);
``` 

## 3.反射源码解析
在开发 Web 项目的时候会遇到过下面的异常：  
``` java
  java.lang.NullPointerException 
  ...
  sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:497)
```
可以看到异常堆栈指出了异常在Method的第497的invoke方法中，其实这里指的invoke方法就是我们反射调用方法中的invoke。  
例如我们经常使用的 Spring 配置中，经常会有相关 Bean 的配置：  
``` java
  <bean class="com.chenshuyi.Apple">
  </bean>
```
当我们在 XML 文件中配置了上面这段配置之后，Spring 便会在启动的时候利用反射去加载对应的 Apple 类。而当 Apple 类不存在或发生启发异常时，
异常堆栈便会将异常指向调用的 invoke 方法。  
从这里可以看出，我们平常很多框架都使用了反射，而反射中最最终的就是 Method 类的 invoke 方法了。  
<br/>
下面我们来看看 JDK 的 invoke 方法到底做了些什么。
<br/>
进入 Method 的 invoke 方法
``` java
  <bean class="com.chenshuyi.Apple">
  </bean>
```
![](/images/posts/Java基础/反射-Method方法源码.png)
![](/images/posts/Java基础/反射-acquireMethodAccessor().png)