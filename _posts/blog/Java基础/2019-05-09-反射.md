---
layout: post
title: 反射使用详解及源码解析
categories: Java基础
description: 反射使用的详解及源码解析
keywords: 反射使用、反射源码
---

## 1.Class类

#### 1.1 什么是Class类
**Class是一个类，封装了当前对象所对应的类的信息**
比如说有一个Person类，一个Order类，一个Book类，这些都是不同的类。现在需要一个类，用来描述类，这就是Class。
正如一个类中有属性，方法，构造器等，因此Class类也有类名，属性，方法，构造器等。Class是用来描述类的类。
<br/>
1) Class类是一个对象照镜子的结果，对象可以看到自己有哪些属性，方法，构造器，实现了哪些接口等等。  
可是，对象为什么需要照镜子呢？  
- 有可能这个对象是别人传过来的
- 有可能没有对象，只有一个全类名 
通过反射，可以得到这个类里面的信息
<br/>
2) 对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个类的有关信息。  
3) Class 对象只能由系统建立对象，一个类（而不是一个对象）在 JVM 中只会有一个Class实例。
 
#### 1.2 什么是反射
反射之中包含了一个「反」字，所以想要解释反射就必须先从「正」开始解释。  
一般情况下，我们使用某个类时必定知道它是什么类，于是我们直接对这个类进行实例化，之后使用这个类对象进行操作。  
``` java
Apple apple = new Apple(); //直接初始化，「正射」
apple.setPrice(4);
```
上面这样子进行类对象的初始化，我们可以理解为「正」。  
反射则是一开始并不知道我要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。  
``` java
Class clz = Class.forName("com.chenshuyi.reflect.Apple");
Method method = clz.getMethod("setPrice", int.class);
Constructor constructor = clz.getConstructor();
Object object = constructor.newInstance();
method.invoke(object, 4);
```
上面两段代码的执行结果，其实是完全一样的。但是其思路完全不一样，第一段代码在未运行时就已经确定了要运行的类（Apple），
而第二段代码则是在运行时通过字符串值才得知要运行的类（com.chenshuyi.reflect.Apple）。  
所以说什么是反射？  
**反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。**
## 2.反射类的使用
Java反射机制主要提供了以下功能：  

- 在运行时构造任意一个类的对象
- 在运行时获取任意一个类所具有的成员变量和方法
- 在运行时调用任意一个对象的方法（属性）
- 生成动态代理
#### 2.1 获取Class对象的三种方式
1) 通过类名获取 类名.class
2) 通过全类名获取 Class.forName(全类名)
3) 通过对象获取 对象名.getClass()
#### 2.2 Method
``` java
Class clazz = Class.forName("com.atguigu.java.fanshe.Person");
```
1) 获取所有方法，包括从父类继承来的，但不能获取私有的方法：  
``` java
 Method[] methods = clazz.getMethods();
 for(Method method:methods){
             System.out.print(" "+method.getName());
 }  
```
2) 获取私有方法，但只获取当前类的  
``` java
 Method[] methods = clazz.getDeclaredMethods();
 for(Method method:methods){
             System.out.print(" "+method.getName());
 }  
```
3) 获取指定的方法  
``` java
 Method method = clazz.getDeclaredMethod("setName", String.class);  
``` 
4) 执行方法  
``` java
Object obje = clazz.newInstance();  
method.invoke(obje,2);  
```
5) 如果一个方法是私有方法,必须在调用invoke之前加上一句method.setAccessible（true）;
#### 2.3 Field
1) 获取所有字段，包括公有的和私有的，但不能获取父类字段  
``` java
 Field[] fields = clazz.getDeclaredFields();
 for(Field field: fields){
             System.out.print(" "+ field.getName());
 } 
```
2) 获取指定字段   
``` java
 Field field = clazz.getDeclaredField("name");
 System.out.println(field.getName()); 
```
3) 使用字段：获取指定对象的指定字段的值  
``` java
 Object val = field.get(person);
 System.out.println(val);
``` 
4) 使用字段：设置指定对象的指定字段的值  
``` java
field.set(person, "DEF");
System.out.println(person.getName());
```
5) 如果字段是私有的，不管是读值还是写值，都必须先调用setAccessible（true）方法
``` java
field = clazz.getDeclaredField("age");
field.setAccessible(true);
System.out.println(field.get(person));
```
#### 2.4 Constructor

## 3.反射源码解析

``` java
public class Target{
    public void f(){
        System.out.println("Target f()");
    }
    public void g(){
        System.out.println("Target g()");
    }
}

public class MyInterceptor implements MethodInterceptor {
    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println("I am intercept begin");
        //Note: 此处一定要使用proxy的invokeSuper方法来调用目标类的方法
        proxy.invokeSuper(obj, args);
        System.out.println("I am intercept end");
        return null;
    }
}

public class Test {
    public static void main(String[] args) {
        //用于保存生成的反编译代码
        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "F:\\code");
         //实例化一个增强器，也就是cglib中的一个class generator
        Enhancer eh = new Enhancer();
         //设置目标类
        eh.setSuperclass(Target.class);
        // 设置拦截对象
        eh.setCallback(new MyInterceptor());
        // 生成代理类并返回一个实例
        Target t = (Target) eh.create();
        t.f();
        t.g();
    }
}
```
运行结果：  
``` java
I am intercept begin
Target f()
I am intercept end
I am intercept begin
Target g()
I am intercept end
```
与JDK动态代理相比，cglib可以实现对一般类的代理而无需实现接口。在上例中通过下列步骤来生成目标类Target的代理类:  
1) 创建Enhancer实例  
2) 通过setSuperclass方法来设置目标类    
3) 通过setCallback 方法来设置拦截对象  
4) create方法生成Target的代理类，并返回代理类的实例  
## 2.代理类分析 
cglib会代理Object中的finalize,equals, toString,hashCode,clone方法，为了清晰的展示代理类我们省略这部分代码，反编译的结果如下：  
``` java
public class Target$$EnhancerByCGLIB$$788444a0 extends Target implements Factory
{
    private boolean CGLIB$BOUND;
    private static final ThreadLocal CGLIB$THREAD_CALLBACKS;
    private static final Callback[] CGLIB$STATIC_CALLBACKS;
    private MethodInterceptor CGLIB$CALLBACK_0;
    private static final Method CGLIB$g$0$Method;
    private static final MethodProxy CGLIB$g$0$Proxy;
    private static final Object[] CGLIB$emptyArgs;
    private static final Method CGLIB$f$1$Method;
    private static final MethodProxy CGLIB$f$1$Proxy;
    
    static void CGLIB$STATICHOOK1()
    {
      CGLIB$THREAD_CALLBACKS = new ThreadLocal();
      CGLIB$emptyArgs = new Object[0];
      Class localClass1 = Class.forName("net.sf.cglib.test.Target$$EnhancerByCGLIB$$788444a0");
      Class localClass2;
      Method[] tmp60_57 = ReflectUtils.findMethods(new String[] { "g", "()V", "f", "()V" }, (localClass2 = Class.forName("net.sf.cglib.test.Target")).getDeclaredMethods());
      CGLIB$g$0$Method = tmp60_57[0];
      CGLIB$g$0$Proxy = MethodProxy.create(localClass2, localClass1, "()V", "g", "CGLIB$g$0");
      CGLIB$f$1$Method = tmp60_57[1];
      CGLIB$f$1$Proxy = MethodProxy.create(localClass2, localClass1, "()V", "f", "CGLIB$f$1");
    }
    
    final void CGLIB$g$0()
    {
      super.g();
    }
    
    public final void g()
    {
      MethodInterceptor tmp4_1 = this.CGLIB$CALLBACK_0;
      if (tmp4_1 == null)
      {
          CGLIB$BIND_CALLBACKS(this);
          tmp4_1 = this.CGLIB$CALLBACK_0;
      }
      if (this.CGLIB$CALLBACK_0 != null) {
          tmp4_1.intercept(this, CGLIB$g$0$Method, CGLIB$emptyArgs, CGLIB$g$0$Proxy);
      }
      else{
          super.g();
      }
    }
}
```
&emsp;&emsp;代理类（Target$$EnhancerByCGLIB$$788444a0）继承了目标类（Target）。代理类为每个目标类的方法生成两个方法，例如针对目标类中的
每个非private方法，代理类会生成两个方法，以g方法为例：一个是@Override的g方法，一个是CGLIB$g$0（CGLIB$g$0相当于目标类的g方法）。
我们在示例代码中调用目标类的方法t.g()时，实际上调用的是代理类中的g()方法。接下来我们着重分析代理类中的g方法，看看是怎么实现的代理功能。  
<br/>
&emsp;&emsp;当调用代理类的g方法时，先判断是否已经存在实现了MethodInterceptor接口的拦截对象，如果没有的话就调用
CGLIB$BIND_CALLBACKS方法来获取拦截对象，CGLIB$BIND_CALLBACKS的反编译结果如下：
``` java
private static final void CGLIB$BIND_CALLBACKS(java.lang.Object);
  Code:
   0:   aload_0
   1:   checkcast       #2; //class net/sf/cglib/test/Target$$EnhancerByCGLIB$$788444a0
   4:   astore_1
   5:   aload_1
   6:   getfield        #212; //Field CGLIB$BOUND:Z
   9:   ifne    52
   12:  aload_1
   13:  iconst_1
   14:  putfield        #212; //Field CGLIB$BOUND:Z
   17:  getstatic       #24; //Field CGLIB$THREAD_CALLBACKS:Ljava/lang/ThreadLocal;
   20:  invokevirtual   #215; //Method java/lang/ThreadLocal.get:()Ljava/lang/Object;
   23:  dup
   24:  ifnonnull       39
   27:  pop
   28:  getstatic       #210; //Field CGLIB$STATIC_CALLBACKS:[Lnet/sf/cglib/proxy/Callback;
   31:  dup
   32:  ifnonnull       39
   35:  pop
   36:  goto    52
   39:  checkcast       #216; //class "[Lnet/sf/cglib/proxy/Callback;"
   42:  aload_1
   43:  swap
   44:  iconst_0
   45:  aaload
   46:  checkcast       #48; //class net/sf/cglib/proxy/MethodInterceptor
   49:  putfield        #36; //Field CGLIB$CALLBACK_0:Lnet/sf/cglib/proxy/MethodInterceptor;
   52:  return
```
CGLIB$BIND_CALLBACKS 先从CGLIB$THREAD_CALLBACKS中get拦截对象，如果获取不到的话，再从CGLIB$STATIC_CALLBACKS来获取，如果也没有则认为该方法不需要代理。  
<br/>
那么拦截对象是如何设置到CGLIB$THREAD_CALLBACKS 或者 CGLIB$STATIC_CALLBACKS中的呢？
<br/>
在Jdk动态代理中拦截对象是在实例化代理类时由构造函数传入的，在cglib中是调用Enhancer的firstInstance方法来生成代理类实例并设置拦截对象的。
firstInstance的调用轨迹为：
1) Enhancer：firstInstance  
2) Enhancer：createUsingReflection  
3) Enhancer：setThreadCallbacks  
4) Enhancer：setCallbacksHelper  
5) Target$$EnhancerByCGLIB$$788444a0 ： CGLIB$SET_THREAD_CALLBACKS  
在第5步，调用了代理类的CGLIB$SET_THREAD_CALLBACKS来完成拦截对象的注入。下面我们看一下CGLIB$SET_THREAD_CALLBACKS的反编译结果:  
``` java
public static void CGLIB$SET_THREAD_CALLBACKS(net.sf.cglib.proxy.Callback[]);
  Code:
   0:   getstatic       #24; //Field CGLIB$THREAD_CALLBACKS:Ljava/lang/ThreadLocal;
   3:   aload_0
   4:   invokevirtual   #207; //Method java/lang/ThreadLocal.set:(Ljava/lang/Object;)V
   7:   return
```
在CGLIB$SET_THREAD_CALLBACKS方法中调用了CGLIB$THREAD_CALLBACKS的set方法来保存拦截对象。
在CGLIB$BIND_CALLBACKS方法中使用了CGLIB$THREAD_CALLBACKS的get方法来获取拦截对象，并保存到CGLIB$CALLBACK_0中。
这样，在我们调用代理类的g方法时，就可以获取到我们设置的拦截对象，然后通过
tmp4_1.intercept(this, CGLIB$g$0$Method, CGLIB$emptyArgs, CGLIB$g$0$Proxy)  来实现代理。这里来解释一下intercept方法的参数含义：  
- @para1 obj ：代理对象本身
- @para2 method ： 被拦截的方法对象
- @para3 args：方法调用入参
- @para4 proxy：用于调用被拦截方法的方法代理对象

这里会有一个疑问，为什么不直接反射调用代理类生成的（CGLIB$g$0）来间接调用目标类的被拦截方法，而使用proxy的invokeSuper方法呢？
这里就涉及到了另外一个点— FastClass。
## 3.Fastclass 机制分析
&emsp;&emsp;Jdk动态代理的拦截对象是通过反射的机制来调用被拦截方法的，反射的效率比较低，所以cglib采用了FastClass的机制来
实现对被拦截方法的调用。FastClass机制就是对一个类的方法建立索引，通过索引来直接调用相应的方法，下面用一个小例子来说明一下，这样比较直观：
``` java
public class test10 {
    public static void main(String[] args){
        Test tt = new Test();
        Test2 fc = new Test2();
        int index = fc.getIndex("f()V");
        fc.invoke(index, tt, null);
    }
}

class Test{
    public void f(){
        System.out.println("f method");
    }
    
    public void g(){
        System.out.println("g method");
    }
}
class Test2{
    public Object invoke(int index, Object o, Object[] ol){
        Test t = (Test) o;
        switch(index){
        case 1:
            t.f();
            return null;
        case 2:
            t.g();
            return null;
        }
        return null;
    }
    
    public int getIndex(String signature){
        switch(signature.hashCode()){
        case 3078479:
            return 1;
        case 3108270:
            return 2;
        }
        return -1;
    }
}
```
上例中，Test2是Test的Fastclass，在Test2中有两个方法getIndex和invoke。在getIndex方法中对Test的每个方法建立索引，
并根据入参（方法名+方法的描述符）来返回相应的索引。Invoke根据指定的索引，以ol为入参调用对象O的方法。
这样就避免了反射调用，提高了效率。代理类（Target$$EnhancerByCGLIB$$788444a0）中与生成Fastclass相关的代码如下：
``` java
Class localClass1 = Class.forName("net.sf.cglib.test.Target$$EnhancerByCGLIB$$788444a0");
localClass2 = Class.forName("net.sf.cglib.test.Target");
CGLIB$g$0$Proxy = MethodProxy.create(localClass2, localClass1, "()V", "g", "CGLIB$g$0");
```
MethodProxy中会对localClass1和localClass2进行分析并生成FastClass，然后再使用getIndex来获取方法g 和 CGLIB$g$0的索引，
具体的生成过程将在后续进行介绍，这里介绍一个关键的内部类：
``` java
private static class FastClassInfo
    {
        FastClass f1; // net.sf.cglib.test.Target的fastclass
        FastClass f2; // Target$$EnhancerByCGLIB$$788444a0 的fastclass
        int i1; //方法g在f1中的索引
        int i2; //方法CGLIB$g$0在f2中的索引
    }
```
MethodProxy 中invokeSuper方法的代码如下：
``` java
FastClassInfo fci = fastClassInfo;
return fci.f2.invoke(fci.i2, obj, args);
```
当调用invokeSuper方法时，实际上是调用代理类的CGLIB$g$0方法，CGLIB$g$0直接调用了目标类的g方法。
所以，在第一节示例代码中我们使用invokeSuper方法来调用被拦截的目标类方法。
