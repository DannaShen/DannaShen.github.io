---
layout: post
title: 并发编程的挑战
categories: 多线程
description: 类加载器相关信息、双亲委派模型及如何破坏
keywords: 类加载器、双亲委派模型、破坏双亲委派模型
---

>并发编程的目的是为了让程序运行得更快，但是，并不是启动更多的线程就能让程序最大限度地并发执行。在进行并发编程时，
如果希望通过多线程执行任务让程序运行得更快，会面临非常多的挑战，比如上下文切换的问题、死锁的问题，以及受限于硬件和软件的
资源限制问题，下面介绍几种并发编程的挑战以及解决方案。
## 1.上下文切换
&emsp;&emsp;即使是单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，
因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒（ms）。  
1) 并发执行不一定比串行执行快，因为线程有创建和上下文切换的开销  
2) 减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。  

- 无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法
取模分段，不同的线程处理不同段的数据。  
- CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需要加锁。  
- 使用最少线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。  
- 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。  

## 2.死锁
&emsp;&emsp;锁是个非常有用的工具，运用场景非常多，因为它使用起来非常简单，而且易于理解。但同时它也会带来一些困扰，那就是可能会引起死锁，
一旦产生死锁，就会造成系统功能不可用。比如t1拿到锁之后，因为一些异常情况没有释放锁（死循环）。又或者是t1拿到一个数据库锁，
释放锁的时候抛出了异常，没释放掉。  
<br/>
现在我们介绍避免死锁的几个常见方法：

- 避免一个线程同时获取多个锁  
- 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源  
- 尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制  
- 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况  

## 3.资源的限制
1) 什么是资源限制  
资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。
例如，服务器的带宽只有2Mb/s，某个资源的下载速度是1Mb/s每秒，系统启动10个线程下载资源，下载速度不会变成10Mb/s，所以在进行并发
编程时，要考虑这些资源的限制。硬件资源限制有带宽的上传/下载速度、硬盘读写速度和CPU的处理速度。软件资源限制有数据库的连接
数和socket连接数等。    
<br/>
2) 资源限制引发的问题  
在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分变成并发执行，但是如果将某段串行的代码并发执行，因为受限于资源，
仍然在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为增加了上下文切换和资源调度的时间。例如，之前看到一段程
序使用多线程在办公网并发地下载和处理数据时，导致CPU利用率达到100%，几个小时都不能运行完成任务，后来修改成单线程，一个小时就执
行完成了。  
<br/>
3) 如何解决资源限制的问题  
对于硬件资源限制，可以考虑使用集群并行执行程序。既然单机的资源有限制，那么就让程序在多机上运行。比如使用ODPS、Hadoop或者自己
搭建服务器集群，不同的机器处理不同的数据。可以通过“数据ID%机器数”，计算得到一个机器编号，然后由对应编号的机器处理这笔数据。
对于软件资源限制，可以考虑使用资源池将资源复用。比如使用连接池将数据库和Socket连接复用，或者在调用对方webservice接口获取数据
时，只建立一个连接。  
<br/>
4) 在资源限制情况下进行并发编程  
如何在资源限制的情况下，让程序执行得更快呢？方法就是，根据不同的资源限制调整程序的并发度，比如下载文件程序依赖于两个资源——
带宽和硬盘读写速度。有数据库操作时，涉及数据库连接数，如果SQL语句执行非常快，而线程的数量比数据库连接数大很多，则
某些线程会被阻塞，等待数据库连接。  


<br/>
&emsp;&emsp;CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，
以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。  
<br/>
&emsp;&emsp;这就像我们同时读两本书，当我们在读一本英文的技术书时，发现某个单词不认识，于是便打开中英文字典，但是在放下英文技术书之前，
大脑必须先记住这本书读到了多少页的第多少行，等查完单词之后，能够继续读这本书。这样的切换是会影响读书效率的，同样上下文
切换也会影响多线程的执行速度。  

#### 1.1 方法内的变量为线程安全
“非线程安全”问题存在于"实例变量"中，如果是方法内部的私有变量， 则不存在“非线程安全”问题，所得结果也就是"线程安全" 的了。
下面的示例就是方法内部声明一个变量时，是不存在"非线程安全"问题的。
``` java
public class HasSelfPrivateNum {

    public void addI(String username){
        try {
        int num;//方法内部变量
        if (username.equals("a")){
            num=100;
            System.out.println("a set over!");
                Thread.sleep(2000);
        }else {
            num=200;
            System.out.println("b set over!");
        }
            System.out.println(username+" num="+num);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
public class ThreadA extends Thread{

    private HasSelfPrivateNum numRef;
    public ThreadA(HasSelfPrivateNum numRef){
        super();
        this.numRef=numRef;
    }
    @Override
    public void run() {
        super.run();
        numRef.addI("a");
    }
}
public class ThreadB extends Thread {

    private HasSelfPrivateNum numRef;
    public ThreadB(HasSelfPrivateNum numRef){
        super();
        this.numRef=numRef;
    }
    @Override
    public void run() {
        super.run();
        numRef.addI("b");
    }
}
public static void main(String[] args) {
        HasSelfPrivateNum numRef=new HasSelfPrivateNum();
        ThreadA athread=new ThreadA(numRef);
        athread.start();
        ThreadB bthread=new ThreadB(numRef);
        bthread.start();
    }
```
结果：
```
a set over!
b set over!
a num=100
b num=200
```
可见，方法中的变量不存在非线程安全问题，永远都是线程安全的。这是方法内部的变量是线程私有的特性造成的。
#### 1.2 实例变量非线程安全
如果多个线程共同访问1个对象中的实例变量，则有可能出现"非线程安全"问题。线程访问的对象中如果有多个实例变量，则运行的结果
有可能出现交叉的情况。如果对象仅有l 个实例变量，则有可能出现覆盖的情况。  
``` java
public class HasSelfPrivateNum {

    int num;//方法外部变量
    public void addI(String username){
        try {
        if (username.equals("a")){
            num=100;
            System.out.println("a set over!");
                Thread.sleep(2000);
        }else {
            num=200;
            System.out.println("b set over!");
        }
            System.out.println(username+" num="+num);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```
其他代码如上。这时，如果想要线程安全只需要在public yoid addl(String useπlame)方法前加关键字synchronized即可，由于是同步访问，
所以先打印出a ，然后打印出b，结果如下：  
```
a set over!
a num=100
b set over!
b num=200
```
#### 1.3 多个对象多个锁
``` java
public static void main(String[] args) {
        HasSelfPrivateNum numRef1=new HasSelfPrivateNum();
        HasSelfPrivateNum numRef2=new HasSelfPrivateNum();
        ThreadA athread=new ThreadA(numRef1);
        athread.start();
        ThreadB bthread=new ThreadB(numRef2);
        bthread.start();
    }
```
结果：  
```
a set over!
b set over!
b num=200
a num=100
```
上面示例是两个线程分别访问同一个类的两个不同实例的相同名称的同步方法，效果却是以异步的方式运行的。本示例由于创建了2个业务对象，
在系统中产生2个锁，所以结果是异步的。
