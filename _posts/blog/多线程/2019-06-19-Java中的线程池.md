---
layout: post
title: Java中线程池
categories: 多线程
description: 类加载器相关信息、双亲委派模型及如何破坏
keywords: 类加载器、双亲委派模型、破坏双亲委派模型
---
>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，
合理地使用线程池能够带来3个好处。  
第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。  
第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。  
第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，
使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用线程池，必须对其实现原理了如指掌。

## 1. 线程池的实现原理
当向线程池提交一个任务之后，线程池是如何处理这个任务的呢？本节来看一下线程池的主要处理流程，处理流程图如图所示。  
![](/images/posts/多线程/)  
从图中可以看出，当提交一个新任务到线程池时，线程池的处理流程如下。  
1）线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。
如果核心线程池里的线程都在执行任务，则进入下个流程。  
2）线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。  
3）线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。否则，则交给饱和策略来处理这个任务。
ThreadPoolExecutor执行execute()方法的示意图，如图所示。  
![](/images/posts/多线程/)  
ThreadPoolExecutor执行execute方法分下面4种情况。  
1）如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。  
2）如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。  
3）如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。  
4）如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。  
<br/>
ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁
（那将会是一个严重的可伸缩瓶颈）。在ThreadPoolExecutor完成预热之后（当前运行的线程数大于等于corePoolSize），
几乎所有的execute()方法调用都是执行步骤2，而步骤2不需要获取全局锁。  
<br/>
源码分析：  
上面的流程分析让我们很直观地了解了线程池的工作原理，让我们再通过源代码来看看是如何实现的，线程池执行任务的方法如下。  

``` java
public void execute(Runnable command) {
        //判断任务有效性
        if (command == null)
            throw new NullPointerException();
        //ctl是一个AtomicInteger类型数据
        //private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
        //其中，ctlOf(RUNNING, 0)就是求的Runing代表的值和0的或操作，因为
        //private static int ctlOf(int rs, int wc)
        // { return rs | wc; }
        //private static final int RUNNING = -1 << COUNT_BITS;
        //COUNT_BITS = Integer.SIZE - 3;
        //所以这个c就是RUNNING值的句柄
        int c = ctl.get();
        //如果运行的线程数小于corePoolSize
        if (workerCountOf(c) < corePoolSize) {
            //如果线程池成功为command任务创建或分配新的线程
            //addWorker方法boolean参数用来判断是否在核心池加任务
            if (addWorker(command, true))
                //退出程序
                return;
            //更新Runing值
            c = ctl.get();
        }
        //private static boolean isRunning(int c) 
        //{return c < SHUTDOWN;}
        //SHUTDOWN值为0，如果小于这个值，表示运行停止
        //offer用来判断任务是否成功入队
        if (isRunning(c) && workQueue.offer(command)) {
            //再次获取RUNNING值
            int recheck = ctl.get();
            //如果command在任务队列中，remove方法将其移除
            if (! isRunning(recheck) && remove(command))
                //将command任务交给饱和策略
                reject(command);
            //如果程序遭到shutdown或shutdownNow方法停止，
            //那么这时会检测到无线程运行，这个时候不要添加任务处理
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        //如果入队失败，那么交给饱和策略
        else if (!addWorker(command, false))
            reject(command);
    }```

``` java
```