---
layout: post
title: Java中线程池
categories: 多线程
description: 类加载器相关信息、双亲委派模型及如何破坏
keywords: 类加载器、双亲委派模型、破坏双亲委派模型
---
## 1. 线程池的实现原理
当向线程池提交一个任务之后，线程池是如何处理这个任务的呢？本节来看一下线程池的主要处理流程，处理流程图如图所示。  
![](/images/posts/多线程/)  
从图中可以看出，当提交一个新任务到线程池时，线程池的处理流程如下。  
1）线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。
如果核心线程池里的线程都在执行任务，则进入下个流程。  
2）线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。  
3）线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。否则，则交给饱和策略来处理这个任务。
ThreadPoolExecutor执行execute()方法的示意图，如图所示。  
![](/images/posts/多线程/)  
ThreadPoolExecutor执行execute方法分下面4种情况。  
1）如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。  
2）如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。  
3）如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。  
4）如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。  
<br/>
ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁
（那将会是一个严重的可伸缩瓶颈）。在ThreadPoolExecutor完成预热之后（当前运行的线程数大于等于corePoolSize），
几乎所有的execute()方法调用都是执行步骤2，而步骤2不需要获取全局锁。  
## 2. 源码分析
#### 2.1 构造函数
